generator client {
  provider = "prisma-client-js"
  output   = "./generated/client"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id                      String         @id @default(cuid())
  email                   String         @unique
  name                    String?
  password                String
  role                    String         @default("CUSTOMER")
  emailVerified           Boolean        @default(false)
  verificationToken       String?        @unique
  verificationTokenExpiry DateTime?
  resetToken              String?        @unique
  resetTokenExpiry        DateTime?
  image                   String?
  deviceFingerprint       String?
  createdAt               DateTime       @default(now())
  updatedAt               DateTime       @updatedAt
  receivedMessages        ChatMessage[]  @relation("ReceivedMessages")
  sentMessages            ChatMessage[]  @relation("SentMessages")
  customer                Customer?
  employee                Employee?
  notifications           Notification[]
  referredPayments        Payment[]      @relation("ReferredPayments")
  refreshTokens           RefreshToken[]
  serviceDelays           ServiceDelay[]
}

model Customer {
  id                String        @id @default(cuid())
  userId            String        @unique
  subscriptionId    String?       @unique
  phone             String?
  gateCode          String?
  serviceDay        String?
  cashAppName       String?
  referralCode      String?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  stripeCustomerId  String?       @unique
  address           Address?
  subscription      Subscription? @relation(fields: [subscriptionId], references: [id])
  user              User          @relation(fields: [userId], references: [id])
  payments          Payment[]
  referralsReceived Referral[]    @relation("Referred")
  referralsGiven    Referral[]    @relation("Referrer")
  services          Service[]

  @@index([subscriptionId])
}

model Address {
  id         String   @id @default(cuid())
  street     String
  city       String
  state      String
  zipCode    String
  customerId String   @unique
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  customer   Customer @relation(fields: [customerId], references: [id])

  @@index([customerId])
}

model Subscription {
  id         String    @id @default(cuid())
  customerId String
  planId     String
  status     String    @default("ACTIVE")
  startDate  DateTime
  endDate    DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  customer   Customer?
  payments   Payment[]
}

model TimeExtension {
  id         String   @id @default(cuid())
  serviceId  String
  employeeId String
  minutes    Int
  reason     String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  service    Service  @relation(fields: [serviceId], references: [id])
  employee   Employee @relation(fields: [employeeId], references: [id])

  @@index([serviceId])
  @@index([employeeId])
}

model Employee {
  id             String           @id @default(cuid())
  userId         String           @unique
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  user           User             @relation(fields: [userId], references: [id])
  payments       Payment[]
  services       Service[]
  serviceAreas   ServiceArea[]
  messages       ServiceMessage[]
  timeExtensions TimeExtension[]
}

model Payment {
  id             String         @id @default(cuid())
  amount         Float
  status         String         @default("PENDING")
  type           String
  serviceId      String?
  employeeId     String?
  customerId     String?
  referredId     String?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  subscriptionId String?
  subscription   Subscription?  @relation(fields: [subscriptionId], references: [id])
  referredBy     User?          @relation("ReferredPayments", fields: [referredId], references: [id])
  customer       Customer?      @relation(fields: [customerId], references: [id])
  service        Service?       @relation(fields: [serviceId], references: [id])
  employee       Employee?      @relation(fields: [employeeId], references: [id])
  retries        PaymentRetry[]

  @@index([serviceId])
  @@index([employeeId])
  @@index([customerId])
  @@index([referredId])
  @@index([subscriptionId])
}

model ServicePhoto {
  id        String    @id @default(cuid())
  serviceId String
  url       String
  type      String
  latitude  Float?
  longitude Float?
  timestamp DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  service   Service   @relation(fields: [serviceId], references: [id])
}

model ServicePlan {
  id          String    @id @default(cuid())
  name        String
  description String?
  price       Float
  duration    Int
  type        String
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  services    Service[]
}

model Service {
  id             String            @id @default(cuid())
  customerId     String
  status         String            @default("SCHEDULED")
  scheduledDate  DateTime
  completedDate  DateTime?
  servicePlanId  String
  employeeId     String?
  serviceAreaId  String?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  location       Location?
  payments       Payment[]
  serviceArea    ServiceArea?      @relation(fields: [serviceAreaId], references: [id])
  employee       Employee?         @relation(fields: [employeeId], references: [id])
  servicePlan    ServicePlan       @relation(fields: [servicePlanId], references: [id])
  customer       Customer          @relation(fields: [customerId], references: [id])
  checklist      ServiceChecklist?
  delays         ServiceDelay[]
  messages       ServiceMessage[]
  photos         ServicePhoto[]
  timeExtensions TimeExtension[]
}

model ServiceChecklist {
  id          String    @id @default(cuid())
  serviceId   String    @unique
  items       Json
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  completedAt DateTime?
  notes       String?
  service     Service   @relation(fields: [serviceId], references: [id])
}

model Location {
  id        String   @id @default(cuid())
  serviceId String   @unique
  latitude  Float
  longitude Float
  address   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  service   Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)
}

model ServiceArea {
  id         String    @id @default(cuid())
  employeeId String
  zipCode    String
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  services   Service[]
  employee   Employee  @relation(fields: [employeeId], references: [id])
}

model PaymentRetry {
  id            String    @id @default(cuid())
  paymentId     String
  status        String    @default("SCHEDULED")
  errorMessage  String?
  retryCount    Int       @default(0)
  nextRetryDate DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  payment       Payment   @relation(fields: [paymentId], references: [id])

  @@index([paymentId])
  @@index([status])
  @@index([nextRetryDate])
}

model ServiceDelay {
  id           String   @id @default(cuid())
  serviceId    String
  reason       String
  type         String
  reportedAt   DateTime @default(now())
  reportedById String
  service      Service  @relation(fields: [serviceId], references: [id])
  reportedBy   User     @relation(fields: [reportedById], references: [id])

  @@index([serviceId])
  @@index([reportedById])
}

model RefreshToken {
  id                String   @id @default(cuid())
  token             String   @unique
  userId            String
  deviceFingerprint String
  isRevoked         Boolean  @default(false)
  expiresAt         DateTime
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([token])
  @@index([deviceFingerprint])
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String
  title     String
  message   String
  read      Boolean  @default(false)
  metadata  Json?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model ChatMessage {
  id         String   @id @default(cuid())
  senderId   String
  receiverId String
  content    String
  read       Boolean  @default(false)
  createdAt  DateTime @default(now())
  receiver   User     @relation("ReceivedMessages", fields: [receiverId], references: [id])
  sender     User     @relation("SentMessages", fields: [senderId], references: [id])

  @@index([senderId])
  @@index([receiverId])
}

model Referral {
  id         String    @id @default(cuid())
  referrerId String
  referredId String?
  code       String    @unique
  status     String    @default("PENDING")
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  referred   Customer? @relation("Referred", fields: [referredId], references: [id])
  referrer   Customer  @relation("Referrer", fields: [referrerId], references: [id])

  @@index([referrerId])
  @@index([referredId])
  @@index([code])
  @@index([status])
}

model ServiceMessage {
  id         String   @id @default(cuid())
  serviceId  String
  employeeId String
  message    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  service    Service  @relation(fields: [serviceId], references: [id])
  employee   Employee @relation(fields: [employeeId], references: [id])

  @@index([serviceId])
  @@index([employeeId])
}
