generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
  relationMode = "prisma"
}

enum PhotoType {
  BEFORE
  AFTER
  ISSUE
  OTHER
}

model User {
  id                      String         @id @default(cuid())
  email                   String         @unique
  name                    String?
  password                String
  role                    String         @default("CUSTOMER")
  emailVerified           Boolean        @default(false)
  verificationToken       String?        @unique
  verificationTokenExpiry DateTime?
  resetToken              String?        @unique
  resetTokenExpiry        DateTime?
  image                   String?
  deviceFingerprint       String?
  createdAt               DateTime       @default(now())
  updatedAt               DateTime       @updatedAt
  receivedMessages        ChatMessage[]  @relation("ReceivedMessages")
  sentMessages            ChatMessage[]  @relation("SentMessages")
  customer                Customer?
  employee                Employee?
  notifications           Notification[]
  referredPayments        Payment[]      @relation("ReferredPayments")
  refreshTokens           RefreshToken[]
  serviceDelays           ServiceDelay[]
  paymentBatches          PaymentBatch[]
}

model Customer {
  id                String        @id @default(cuid())
  userId            String        @unique
  subscriptionId    String?       @unique
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  stripeCustomerId  String?       @unique
  gateCode          String?
  phone             String?
  serviceDay        String?
  cashAppName       String?
  referralCode      String?
  address           Address?
  subscription      Subscription? @relation(fields: [subscriptionId], references: [id])
  user              User          @relation(fields: [userId], references: [id])
  payments          Payment[]
  referralsReceived Referral[]    @relation("Referred")
  referralsGiven    Referral[]    @relation("Referrer")
  services          Service[]

  @@index([subscriptionId])
}

model Address {
  id         String   @id @default(cuid())
  street     String
  city       String
  state      String
  zipCode    String
  customerId String   @unique
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  customer   Customer @relation(fields: [customerId], references: [id])

  @@index([customerId])
}

model Subscription {
  id         String    @id @default(cuid())
  customerId String
  planId     String
  status     String    @default("ACTIVE")
  startDate  DateTime
  endDate    DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  customer   Customer?
  payments   Payment[]
}

model TimeExtension {
  id         String   @id @default(cuid())
  serviceId  String
  employeeId String
  minutes    Int
  reason     String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  service    Service  @relation(fields: [serviceId], references: [id])
  employee   Employee @relation(fields: [employeeId], references: [id])

  @@index([serviceId])
  @@index([employeeId])
}

model Employee {
  id              String           @id @default(cuid())
  userId          String           @unique
  phone           String?
  cashAppUsername String?
  stripeAccountId String?         @unique
  preferredPaymentMethod String?  // CASH_APP or STRIPE
  bio             String?
  availability    Json?
  status          String           @default("ACTIVE")
  rating          Float?
  completedJobs   Int              @default(0)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  user            User             @relation(fields: [userId], references: [id])
  payments        Payment[]
  services        Service[]
  serviceAreas    ServiceArea[]
  messages        ServiceMessage[]
  timeExtensions  TimeExtension[]
  earnings        Earning[]
}

model Payment {
  id             String         @id @default(cuid())
  amount         Float          // Total payment amount
  stripeFee      Float?         // Stripe processing fee
  netAmount      Float?         // Net amount after fees
  status         String         @default("PENDING") // PENDING, APPROVED, PAID, FAILED
  type           String
  serviceId      String?
  employeeId     String?
  customerId     String?
  referredId     String?
  paymentMethod  String?        // CASH, CASH_APP, CHECK, STRIPE, etc.
  paidAt         DateTime?      // When the payment was actually sent
  approvedAt     DateTime?      // When the payment was approved by admin
  approvedBy     String?        // Admin who approved the payment
  notes          String?        // Additional information about the payment
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  subscriptionId String?
  stripePaymentIntentId String?
  stripeInvoiceId String?
  stripeTransferId String?      // ID of Stripe transfer (for employee payouts)
  // Refund fields
  refundedAmount Float?         // Amount refunded
  refundedAt     DateTime?      // When the refund was processed
  refundedBy     String?        // Admin who processed the refund
  refundReason   String?        // Reason for the refund
  refundStatus   String?        // PENDING, COMPLETED, FAILED
  refundTransactionId String?   // ID of refund transaction from payment provider
  batchId        String?        // ID of the batch this payment belongs to
  subscription   Subscription?  @relation(fields: [subscriptionId], references: [id])
  referredBy     User?          @relation("ReferredPayments", fields: [referredId], references: [id])
  customer       Customer?      @relation(fields: [customerId], references: [id])
  service        Service?       @relation(fields: [serviceId], references: [id])
  employee       Employee?      @relation(fields: [employeeId], references: [id])
  retries        PaymentRetry[]
  earnings       Earning[]
  auditLogs      PaymentAuditLog[]
  batch          PaymentBatch?  @relation(fields: [batchId], references: [id])

  @@index([serviceId])
  @@index([employeeId])
  @@index([customerId])
  @@index([referredId])
  @@index([subscriptionId])
  @@index([status])
  @@index([batchId])
}

model ServicePhoto {
  id        String    @id @default(cuid())
  url       String
  type      PhotoType
  serviceId String
  service   Service   @relation(fields: [serviceId], references: [id])
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  expiresAt DateTime? // When this photo should be deleted
}

model ServicePlan {
  id          String    @id @default(cuid())
  name        String
  description String?
  price       Float
  duration    Int
  type        String
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  services    Service[]
}

model Service {
  id             String            @id @default(cuid())
  customerId     String
  status         String            @default("SCHEDULED")
  scheduledDate  DateTime
  completedDate  DateTime?
  servicePlanId  String
  employeeId     String?
  serviceAreaId  String?
  potentialEarnings Float?          // What the scooper would earn for this job
  stripeFees     Float?            // Stripe processing fee for this service
  netAmount      Float?            // Net amount after stripe fees
  paymentStatus  String           @default("PENDING") // PENDING, APPROVED, PAID
  paymentApprovedAt DateTime?     // When admin approved the payment
  paymentApprovedBy String?       // Admin who approved the payment
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  location       Location?
  payments       Payment[]
  serviceArea    ServiceArea?      @relation(fields: [serviceAreaId], references: [id])
  employee       Employee?         @relation(fields: [employeeId], references: [id])
  servicePlan    ServicePlan       @relation(fields: [servicePlanId], references: [id])
  customer       Customer          @relation(fields: [customerId], references: [id])
  checklist      ServiceChecklist?
  delays         ServiceDelay[]
  messages       ServiceMessage[]
  photos         ServicePhoto[]
  timeExtensions TimeExtension[]
  earnings       Earning[]

  @@index([paymentStatus])
  @@index([employeeId])
  @@index([serviceAreaId])
}

model ServiceChecklist {
  id          String    @id @default(cuid())
  serviceId   String    @unique
  items       Json
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  completedAt DateTime?
  notes       String?
  service     Service   @relation(fields: [serviceId], references: [id])
}

model Location {
  id        String   @id @default(cuid())
  serviceId String   @unique
  latitude  Float
  longitude Float
  address   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  service   Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)
}

model ServiceArea {
  id         String    @id @default(cuid())
  employeeId String
  zipCode    String
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  services   Service[]
  employee   Employee  @relation(fields: [employeeId], references: [id])
}

model PaymentRetry {
  id                   String    @id @default(cuid())
  paymentId            String
  status               String    // SCHEDULED, PENDING, SUCCESS, FAILED
  retryCount           Int       @default(0)
  nextRetryDate        DateTime
  errorMessage         String?
  scheduledDate        DateTime  @default(now())
  processedDate        DateTime?
  stripePaymentIntentId String?
  payment              Payment   @relation(fields: [paymentId], references: [id])

  @@index([paymentId])
  @@index([status])
  @@index([nextRetryDate])
}

model ServiceDelay {
  id           String   @id @default(cuid())
  serviceId    String
  reason       String
  type         String
  reportedAt   DateTime @default(now())
  reportedById String
  service      Service  @relation(fields: [serviceId], references: [id])
  reportedBy   User     @relation(fields: [reportedById], references: [id])

  @@index([serviceId])
  @@index([reportedById])
}

model RefreshToken {
  id                String   @id @default(cuid())
  token             String   @unique
  userId            String
  deviceFingerprint String
  isRevoked         Boolean  @default(false)
  expiresAt         DateTime
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  user              User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([token])
  @@index([deviceFingerprint])
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String
  title     String
  message   String
  read      Boolean  @default(false)
  metadata  Json?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model ChatMessage {
  id         String   @id @default(cuid())
  senderId   String
  receiverId String
  content    String
  read       Boolean  @default(false)
  createdAt  DateTime @default(now())
  receiver   User     @relation("ReceivedMessages", fields: [receiverId], references: [id])
  sender     User     @relation("SentMessages", fields: [senderId], references: [id])

  @@index([senderId])
  @@index([receiverId])
}

model Referral {
  id         String    @id @default(cuid())
  referrerId String
  referredId String?
  code       String    @unique
  status     String    @default("PENDING")
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  referred   Customer? @relation("Referred", fields: [referredId], references: [id])
  referrer   Customer  @relation("Referrer", fields: [referrerId], references: [id])

  @@index([referrerId])
  @@index([referredId])
  @@index([code])
  @@index([status])
}

model ServiceMessage {
  id         String   @id @default(cuid())
  serviceId  String
  employeeId String
  message    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  service    Service  @relation(fields: [serviceId], references: [id])
  employee   Employee @relation(fields: [employeeId], references: [id])

  @@index([serviceId])
  @@index([employeeId])
}

model Earning {
  id              String   @id @default(cuid())
  amount          Float    // Amount earned by the scooper for this service
  status          String   @default("PENDING") // PENDING, APPROVED, PAID, FAILED
  serviceId       String   // Reference to the completed service
  employeeId      String   // The scooper who earned this
  paidVia         String?  // CASH_APP or STRIPE
  paidAt          DateTime?
  approvedAt      DateTime? // When the admin approved the payment
  approvedBy      String?   // Admin who approved the payment
  stripeTransferId String? @unique
  errorMessage    String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  service         Service  @relation(fields: [serviceId], references: [id])
  employee        Employee @relation(fields: [employeeId], references: [id])
  payments        Payment[]

  @@index([serviceId])
  @@index([employeeId])
  @@index([status])
}

// Audit log for payment system
model PaymentAuditLog {
  id          String   @id @default(cuid())
  paymentId   String
  eventType   String   // CREATED, STATUS_CHANGED, APPROVED, PROCESSED, REFUNDED, etc.
  details     String   // JSON string with event details
  performedBy String   // USER_ID or SYSTEM
  timestamp   DateTime @default(now())
  payment     Payment  @relation(fields: [paymentId], references: [id])

  @@index([paymentId])
  @@index([eventType])
  @@index([timestamp])
  @@index([performedBy])
}

// New Payment Batch model for managing payments in batches
model PaymentBatch {
  id                 String    @id @default(cuid())
  name               String
  description        String?
  status             String    // DRAFT, PROCESSING, COMPLETED, PARTIAL, FAILED
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  createdById        String
  createdBy          User      @relation(fields: [createdById], references: [id])
  processingStartedAt DateTime?
  completedAt        DateTime?
  notes              String?
  payments           Payment[]
}

// Payment reconciliation
model PaymentReconciliationReport {
  id                     String    @id @default(cuid())
  timestamp              DateTime  @default(now())
  totalRecords           Int
  matchedCount           Int
  mismatchCount          Int
  missingFromStripeCount Int
  missingFromSystemCount Int
  items                  PaymentReconciliationItem[]

  @@index([timestamp])
}

model PaymentReconciliationItem {
  id           String              @id @default(cuid())
  reportId     String
  paymentId    String?
  stripeId     String?
  systemAmount Float?
  stripeAmount Float?
  matchStatus  String              // MATCHED, AMOUNT_MISMATCH, MISSING_FROM_STRIPE, MISSING_FROM_SYSTEM
  notes        String
  report       PaymentReconciliationReport @relation(fields: [reportId], references: [id])

  @@index([reportId])
  @@index([paymentId])
  @@index([matchStatus])
}

model CleanupTask {
  id           String    @id @default(cuid())
  taskType     String    // PHOTO_CLEANUP, etc.
  status       String    // PENDING, COMPLETED, FAILED
  scheduledFor DateTime
  targetId     String    // ID of the object to clean up (e.g., serviceId)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  completedAt  DateTime?
  notes        String?
}

model RateLimit {
  id        String   @id @default(cuid())
  key       String   @unique
  count     Int      @default(1)
  resetTime DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([key])
  @@index([resetTime])
}

model Cache {
  id        String   @id @default(cuid())
  key       String   @unique
  value     Json
  expiresAt DateTime
  tags      String[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([key])
  @@index([tags])
  @@index([expiresAt])
}
